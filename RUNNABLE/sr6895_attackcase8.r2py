def close_after(t):
    def sleep_for():
        # after sleeping t sec, terminate the program
        sleep(t)
        log("Operation Unsuccessful as Program Triggered Race Condition / Infinite Loop\n")
        exitall()
    return sleep_for

def threadone():
    # New File Operation
    #READ Operation
    #if myfile.readat(2,0) == "SE":
    myfile = openfile("testfile.txt", True)
    try:
        #WRITE Operation
        myfile.writeat("hello",0)
        sleep(3)
        myfile.close()
    except RepyArgumentError:
        pass
    finally:
        exitall()

def threadtwo():
    try:
        #REMOVE Operation
        if "testfile.txt" in listfiles():
            removefile("testfile.txt")
        log("ATTACK 14 | ERROR | Multithreading- File removed while another thread is writing on the same file!\n")
    finally:
        exitall()

terminate_program = close_after(4)
createthread(terminate_program)
createthread(threadone)
createthread(threadtwo)
